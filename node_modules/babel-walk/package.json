{
  "_args": [
    [
      {
        "raw": "babel-walk@3.0.0-canary-5",
        "scope": null,
        "escapedName": "babel-walk",
        "name": "babel-walk",
        "rawSpec": "3.0.0-canary-5",
        "spec": "3.0.0-canary-5",
        "type": "version"
      },
      "D:\\Programming\\Web\\613\\node_modules\\with"
    ]
  ],
  "_from": "babel-walk@3.0.0-canary-5",
  "_hasShrinkwrap": false,
  "_id": "babel-walk@3.0.0-canary-5",
  "_inCache": true,
  "_location": "/babel-walk",
  "_nodeVersion": "12.16.3",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/babel-walk_3.0.0-canary-5_1590439909023_0.8600387427590168"
  },
  "_npmUser": {
    "name": "babel-walk-bot",
    "email": "babel-walk-bot@rollingversions.com"
  },
  "_npmVersion": "6.14.4",
  "_phantomChildren": {},
  "_requested": {
    "raw": "babel-walk@3.0.0-canary-5",
    "scope": null,
    "escapedName": "babel-walk",
    "name": "babel-walk",
    "rawSpec": "3.0.0-canary-5",
    "spec": "3.0.0-canary-5",
    "type": "version"
  },
  "_requiredBy": [
    "/with"
  ],
  "_resolved": "https://registry.npmjs.org/babel-walk/-/babel-walk-3.0.0-canary-5.tgz",
  "_shasum": "f66ecd7298357aee44955f235a6ef54219104b11",
  "_shrinkwrap": null,
  "_spec": "babel-walk@3.0.0-canary-5",
  "_where": "D:\\Programming\\Web\\613\\node_modules\\with",
  "author": {
    "name": "Timothy Gu",
    "email": "timothygu99@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/pugjs/babel-walk/issues"
  },
  "dependencies": {
    "@babel/types": "^7.9.6"
  },
  "description": "Lightweight Babel AST traversal",
  "devDependencies": {
    "@forbeslindesay/tsconfig": "^2.0.0",
    "@types/node": "^14.0.5",
    "prettier": "^2.0.5",
    "rimraf": "^3.0.2",
    "tslint": "^6.1.2",
    "typescript": "^3.9.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-GAwkz0AihzY5bkwIY5QDR+LvsRQgB/B+1foMPvi0FZPMl5fjD7ICiznUiBdLYMH1QYe6vqu4gWYytZOccLouFw==",
    "shasum": "f66ecd7298357aee44955f235a6ef54219104b11",
    "tarball": "https://registry.npmjs.org/babel-walk/-/babel-walk-3.0.0-canary-5.tgz",
    "fileCount": 13,
    "unpackedSize": 110137,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezC/lCRA9TVsSAnZWagAAkLkP/20LHCrDPLMgB+hYf8tg\nPIMZCZvtL1aI2rbES2cw+NEYWdz84BV4SC2WepYk1kCXc3xSYyA1j+eSn/0p\nKfHy0nfjtKK6nbEWVl6ADGVPdwj0QSZNdLfybKpf6lKRHMJja4lFPf2sM2vh\n4YlwXdLm+xF6ffLzNXAj/aNAbwV9PrKI9iCgxc85sOCQVdXiE6t/Gtd0U8Mh\nca8uJts1JzzkPuQhN3ESA1e86MFCCfid06OkEDCbFOg/UkB8YLlNr0k/hAwp\nn7O8yS3oziClqjBavDygEETHnMoAaTE5aFdhNnt5TFzErFNGe97DlCF+Ju5c\n8Nt5TQvxM7OIMKvWOosG2yn2YUlS6OtBBwRzICu9hbrCEg3/U4NIY+mFVL2K\n0/koTNyg2qc35WJdbZElM3Qh0hkeGnA4NusYi2BHWBjfxgMcRPN6pGAtGbL6\n8/lgwXY7S1m9D6voD4AxE5ZjJZd1pY/EWkE3AJoXrJh0NMW2UG0Hli6Gueyo\nebsmylVYgDis4lQM3b60V+l0WcjfJSEWczm4P0J6/Dm8kguWsDJ7a3N+Pq16\njS6ApFWhD2gZtXgM44TPRRcaRGxzeBWoQjWi60Jdg0uyL8+xvk7kXzaEvDTJ\nqeS2mXBOHrpzn5+1BGxWM0BJYpmohcMFylxJYVem4aUcn3wtLvT1947U5I3V\nLfe3\r\n=BUWB\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">= 10.0.0"
  },
  "gitHead": "aea4d8fae63e4a4e93f04dcd7ee5858384593e0a",
  "homepage": "https://github.com/pugjs/babel-walk#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "babel-walk-bot",
      "email": "babel-walk-bot@rollingversions.com"
    },
    {
      "name": "forbeslindesay",
      "email": "forbes@lindesay.co.uk"
    }
  ],
  "name": "babel-walk",
  "optionalDependencies": {},
  "readme": "# babel-walk\n\nLightweight AST traversal tools for [Babel] ASTs.\n\n[Babel] supplies the wonderful [babel-traverse] module for walking Babel ASTs. Problem is, babel-traverse is very heavyweight, as it is designed to supply utilities to make all sorts of AST transformations possible. For simple AST walking without transformation, babel-traverse brings a lot of overhead.\n\nThis module loosely implements the API of Acorn parser's [walk module], which is a lightweight AST walker for the ESTree AST format.\n\nIn my tests, babel-walk's ancestor walker (the most complex walker provided by this module) is about 8 times faster than babel-traverse, if the visitors are cached and the same AST is used for all runs. It is about 16 times faster if a fresh AST is used every run.\n\n[![Build Status](https://img.shields.io/github/workflow/status/pugjs/babel-walk/Publish%20Canary/master?style=for-the-badge)](https://github.com/pugjs/babel-walk/actions?query=workflow%3A%22Publish+Canary%22)\n[![Rolling Versions](https://img.shields.io/badge/Rolling%20Versions-Enabled-brightgreen?style=for-the-badge)](https://rollingversions.com/pugjs/babel-walk)\n[![NPM version](https://img.shields.io/npm/v/babel-walk?style=for-the-badge)](https://www.npmjs.com/package/babel-walk)\n\n[babel]: https://babeljs.io/\n[babel-traverse]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-babel-traverse\n[walk module]: https://github.com/ternjs/acorn#distwalkjs\n\n## Installation\n\n```sh\n$ npm install babel-walk\n```\n\n## API\n\n```js\nvar walk = require('babel-walk');\n```\n\n### walk.simple(visitors)(node, state)\n\nDo a simple walk over the AST. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state)`, where `node` is the AST node, and `state` is the same `state` passed to `walk.simple`.\n\nWhen `walk.simple` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to cache the result of calling `walk.simple(visitors)` and communicate state leveraging the `state` parameter.\n\nAll [babel-types] aliases (e.g. `Expression`) work, but the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) does not.\n\n### walk.ancestor(visitors)(node, state)\n\nDo a simple walk over the AST, but memoizing the ancestors of the node and making them available to the visitors. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state, ancestors)`, where `node` is the AST node, `state` is the same `state` passed to `walk.ancestor`, and `ancestors` is an array of ancestors to the node (with the outermost node being `[0]` and the current node being `[ancestors.length - 1]`). If `state` is not specified in the call to `walk.ancestor`, the `state` parameter will be set to `ancestors`.\n\nWhen `walk.ancestor` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to cache the result of calling `walk.ancestor(visitors)` and communicate state leveraging the `state` parameter.\n\nAll [babel-types] aliases (e.g. `Expression`) work, but the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) does not.\n\n### walk.recursive(visitors)(node, state)\n\nDo a recursive walk over the AST, where the visitors are responsible for continuing the walk on the child nodes of their target node. `node` should be the AST node to walk, and `visitors` an object containing Babel [visitors]. Each visitor function will be called as `(node, state, c)`, where `node` is the AST node, `state` is the same `state` passed to `walk.recursive`, and `c` is a function that takes a single node as argument and continues walking _that_ node. If no visitor for a node is provided, the default walker algorithm will still be used.\n\nWhen `walk.recursive` is called with a fresh set of visitors, it will first \"explode\" the visitors (e.g. expanding `Visitor(node, state) {}` to `Visitor() { enter(node, state) {} }`). This exploding process can take some time, so it is recommended to cache the result of calling `walk.recursive(visitors)` and communicate state leveraging the `state` parameter.\n\nUnlike other babel-walk walkers, `walk.recursive` does not call the `exit` visitor, only the `enter` (the default) visitor, of a specific node type.\n\nAll [babel-types] aliases (e.g. `Expression`) work, but the union syntax (e.g. `'Identifier|AssignmentPattern'(node, state) {}`) does not.\n\nIn the following example, we are trying to count the number of functions in the outermost scope. This means, that we can simply walk all the statements and increment a counter if it is a function declaration or expression, and then stop walking. Note that we do not specify a visitor for the `Program` node, and the default algorithm for walking `Program` nodes is used (which is what we want). Also of note is how I bring the `visitors` object outside of `countFunctions` so that the object can be cached to improve performance.\n\n```js\nimport * as t from 'babel-types';\nimport {parse} from 'babel';\nimport * as walk from 'babel-walk';\n\nconst visitors = walk.recursive({\n  Statement(node, state, c) {\n    if (t.isVariableDeclaration(node)) {\n      for (let declarator of node.declarations) {\n        // Continue walking the declarator\n        c(declarator);\n      }\n    } else if (t.isFunctionDeclaration(node)) {\n      state.counter++;\n    }\n  },\n\n  VariableDeclarator(node, state) {\n    if (t.isFunction(node.init)) {\n      state.counter++;\n    }\n  },\n});\n\nfunction countFunctions(node) {\n  const state = {\n    counter: 0,\n  };\n  visitors(node, state);\n  return state.counter;\n}\n\nconst ast = parse(`\n  // Counts\n  var a = () => {};\n\n  // Counts\n  function b() {\n    // Doesn't count\n    function c() {\n    }\n  }\n\n  // Counts\n  const c = function d() {};\n`);\n\ncountFunctions(ast);\n// = 3\n```\n\n[babel-types]: https://github.com/babel/babel/tree/master/packages/babel-types\n[cache your visitors]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-optimizing-nested-visitors\n[visitors]: https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-visitors\n\n## Caveat\n\nFor those of you migrating from Acorn to Babel, there are a few things to be aware of.\n\n1. The visitor caching suggestions do not apply to Acorn's walk module, but do for babel-walk.\n\n2. babel-walk does not provide any of the other functions Acorn's walk module provides (e.g. `make`, `findNode*`).\n\n3. babel-walk does not use a `base` variable. The walker algorithm is the same as what babel-traverse uses.\n   - That means certain nodes that are not walked by Acorn, such as the `property` property of a non-computed `MemberExpression`, are walked by babel-walk.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pugjs/babel-walk.git"
  },
  "scripts": {
    "build": "tsc && node lib",
    "lint": "tslint './src/**/*.{ts,tsx}' -t verbose -p .",
    "postbuild": "rimraf lib/**/__tests__",
    "prettier:check": "prettier --ignore-path .gitignore --list-different './**/*.{md,json,yaml,js,jsx,ts,tsx}'",
    "prettier:write": "prettier --ignore-path .gitignore --write './**/*.{md,json,yaml,js,jsx,ts,tsx}'"
  },
  "version": "3.0.0-canary-5",
  "warnings": [
    {
      "code": "ENOTSUP",
      "required": {
        "node": ">= 10.0.0"
      },
      "pkgid": "babel-walk@3.0.0-canary-5"
    }
  ]
}
